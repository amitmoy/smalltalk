Morph subclass: #Board	instanceVariableNames: 'lastQueen cellSize solved'	classVariableNames: ''	poolDictionaries: ''	category: '8QUEENS-OOP'!!Board commentStamp: 'init 1/2/2021 11:42' prior: 0!this object represent the game chess board 8 by 8 to solve the 8queen problem!!Board methodsFor: 'as yet unclassified' stamp: 'init 1/3/2021 21:24'!drawOn: aCanvas	"comment stating purpose of message"! !!Board methodsFor: 'as yet unclassified' stamp: 'ס 1/4/2021 14:53'!handleKeystroke: anEvent	"comment stating purpose of message"	| keyVal |	keyVal:= anEvent keyValue.	keyVal = 29 ifTrue: [solved ifTrue:[[lastQueen nextSolution ifTrue: [Transcript show: lastQueen result printString; cr.]																ifFalse:[Transcript show: 'End Of Solutions.'; cr].]fork]														ifFalse: [self solve.																solved:=true.]].! !!Board methodsFor: 'as yet unclassified' stamp: 'init 1/4/2021 11:54'!handlesMouseOver: anEvent	"comment stating purpose of message"	^true.! !!Board methodsFor: 'as yet unclassified' stamp: 'ס 1/4/2021 14:51'!initialize	"init the lastQueen variable to be the Terminator Queen and sets the other 8 normal Queens to be neighbors with the correct column for each queen"	super initialize.	cellSize:= 40.	solved:= false.	self extent: ((cellSize*8)@(cellSize*8)).	(0 to: 7 ) do: [:row | (0 to: 7) do:[ :col | |cell|(col+row) even ifTrue: [cell:= Morph new color: Color gray]															ifFalse: [cell:= Morph new color: Color brown].											cell extent: (cellSize@cellSize).											cell position: self position + ((cellSize*row) @ (cellSize*col)).											self addMorph: cell. ].].		lastQueen := QueenTerminator new.	(0 to: 7) do: [:i | lastQueen := Queen new initialize; setColumn: i neighbor: lastQueen.					lastQueen position: self position + ((i*cellSize) @ 0).					self addMorphFront: lastQueen.].! !!Board methodsFor: 'as yet unclassified' stamp: 'init 1/4/2021 11:54'!mouseEnter: anEvent	"comment stating purpose of message"	anEvent hand newKeyboardFocus: self.! !!Board methodsFor: 'as yet unclassified' stamp: 'init 1/4/2021 11:55'!mouseLeave: anEvent	"comment stating purpose of message"	anEvent hand newKeyboardFocus: nil.! !!Board methodsFor: 'as yet unclassified' stamp: 'ס 1/4/2021 14:24'!solve	"this method solves the 8queens problem"	Transcript clear.	[lastQueen firstSolution ifTrue: [Transcript show: lastQueen result printString; cr.]							ifFalse: [Transcript show: 'No Solutions.'; cr]]fork.! !Morph subclass: #BoardMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '8QUEENS-OOP'!Morph subclass: #Queen	instanceVariableNames: 'row column neighbor cellSize'	classVariableNames: ''	poolDictionaries: ''	category: '8QUEENS-OOP'!!Queen methodsFor: 'as yet unclassified' stamp: 'ס 1/4/2021 15:00'!advance	"Moves this Queen to the next possible row"	row = 8 ifTrue: [neighbor nextSolution ifFalse:[ color:=Color transparent.													^false].					color:= Color orange.					self removeArrows.					10 timesRepeat:[(Delay forMilliseconds:30) wait.					self position: self position - (0@(row*0.1*cellSize))].					row:=0].	color:= Color orange.	self removeArrows.	row:= row + 1.	10 timesRepeat:[(Delay forMilliseconds:10) wait.					self position: self position + (0@(cellSize*0.1))].	color:=Color transparent.	"self setRow: row."	^true! !!Queen methodsFor: 'as yet unclassified' stamp: 'ס 1/4/2021 13:48'!canAttack: testRow x: testColumn	"return if an of the queens can attack this position"	| columnDiff |	columnDiff := testColumn - column.	((row = testRow or: [row + columnDiff = testRow]) or: [row - columnDiff = testRow]) ifTrue:[ 																								^true].	^neighbor canAttack: testRow x: testColumn queen: self ! !!Queen methodsFor: 'as yet unclassified' stamp: 'ס 1/4/2021 14:57'!canAttack: testRow x: testColumn queen: aQueen	"return if an of the queens can attack this position"	| columnDiff arrow |	columnDiff := testColumn - column.	((row = testRow or: [row + columnDiff = testRow]) or: [row - columnDiff = testRow]) ifTrue:[arrow := (LineMorph from: self center to: aQueen center color: Color red width: 1) makeForwardArrow.																								aQueen addMorph: arrow.																								^true].	^neighbor canAttack: testRow x: testColumn queen: aQueen.! !!Queen methodsFor: 'as yet unclassified' stamp: 'init 1/4/2021 09:32'!firstSolution	"returns if found the first solution"	neighbor firstSolution.	row := 1.	self setRow: row.	^self moveToNextNonAttackRow! !!Queen methodsFor: 'as yet unclassified' stamp: 'init 1/4/2021 08:28'!initialize	"comment stating purpose of message"		|queenImage|	super initialize.	cellSize:=40.	queenImage:= ImageMorph new newForm:((ImageReadWriter formFromFileNamed:'queen.png') magnifyBy:0.02).	self extent: cellSize@cellSize.	color:= Color transparent.	self addMorph: queenImage.	queenImage center: self center.! !!Queen methodsFor: 'as yet unclassified' stamp: 'ס 1/4/2021 14:40'!moveToNextNonAttackRow	"tries to move to the next non attacked cell returns if succeed"		self changed.	[neighbor canAttack: row x: column queen: self] whileTrue: [		self advance ifFalse: [		^false]].	^true! !!Queen methodsFor: 'as yet unclassified' stamp: 'init 1/4/2021 09:28'!nextSolution	"finds the next solution and returns if succeed"	^self advance and: [self moveToNextNonAttackRow]		! !!Queen methodsFor: 'as yet unclassified' stamp: 'ס 1/4/2021 14:59'!removeArrows	"comment stating purpose of message"	self submorphs do:[:i | (i isMemberOf: PolygonMorph) ifTrue:[self removeMorph: i.]. ]! !!Queen methodsFor: 'as yet unclassified' stamp: 'init 1/2/2021 12:15'!result	"add this queen row to the result list"	^neighbor result addLast: row; yourself! !!Queen methodsFor: 'as yet unclassified' stamp: 'init 1/2/2021 11:51'!setColumn: aColumn neighbor: aQueen	"Sets the column and neighbor of this Queen"	column := aColumn.	neighbor := aQueen.! !!Queen methodsFor: 'as yet unclassified' stamp: 'init 1/4/2021 12:12'!setRow: row	"sets the Morph row"	self position: (self position x)@(row-1*cellSize + owner position y).! !Object subclass: #QueenTerminator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '8QUEENS-OOP'!!QueenTerminator commentStamp: 'init 1/2/2021 11:40' prior: 0!this is a dummy queen to terminate the queen recursive calls!!QueenTerminator methodsFor: 'as yet unclassified' stamp: 'init 1/2/2021 11:02'!canAttack: testRow x: testColumn	"Returns false anyway to resemble regular queen canAttack x"	^false! !!QueenTerminator methodsFor: 'as yet unclassified' stamp: 'init 1/4/2021 12:10'!canAttack: testRow x: testColumn queen: aQueen	"Returns false anyway to resemble regular queen canAttack x"	^false! !!QueenTerminator methodsFor: 'as yet unclassified' stamp: 'init 1/2/2021 11:37'!firstSolution	"returns true anyway to resemble normal queen behavior"	^true! !!QueenTerminator methodsFor: 'as yet unclassified' stamp: 'init 1/2/2021 11:38'!nextSolution	"returns false anyway to resemble normal queen behavior"	^false! !!QueenTerminator methodsFor: 'as yet unclassified' stamp: 'init 1/2/2021 11:40'!result	"returns a new empty collection"	^OrderedCollection new! !