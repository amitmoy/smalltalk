CircleMorph subclass: #BouncyBall	instanceVariableNames: 'angle'	classVariableNames: ''	poolDictionaries: ''	category: 'BouncyBall'!!BouncyBall commentStamp: 'MJK 7/5/2012 14:54' prior: 0!A BouncyBall is a ball, which bounces inside an owner area.An example (select the code and Do it):|m|m := Morph new openInWorld.m position: 150@50.m extent: 400@300.m addMorph: BouncyBall new.m addMorph: BouncyBall new.m addMorph: BouncyBall new.Creates a morph with three bouncing balls.BouncyBall new openInWorld.Creates a bouncy ball inside the world.!!BouncyBall methodsFor: 'geometry' stamp: 'MJK 7/5/2012 14:35'!checkBounds	"Checks if the ball is inside the boundaries of the owner object. If not, return the ball to the top left corner of the owner."	((self position x < owner bounds left) or: (self position x > owner bounds right) or: (self position y < owner bounds top) or: (self position y > owner bounds bottom)) ifTrue: [self position: owner bounds topLeft].! !!BouncyBall methodsFor: 'geometry' stamp: 'MJK 7/11/2012 14:46'!direction	"Return the angle in degrees."		^angle radiansToDegrees! !!BouncyBall methodsFor: 'geometry' stamp: 'MJK 7/5/2012 14:39'!direction:angleInDec	"Receive the angle in degrees and store it in radians."		|tmpAngle|		tmpAngle := angleInDec.		"Make sure that the angle is never directly towards any of the sides."	(tmpAngle \\ 90 = 0) ifTrue: [tmpAngle := tmpAngle + 1].		"If the angle is negative, then convert it to the range 0...359 degrees."	(tmpAngle < 0) ifTrue: [tmpAngle := 360 + angleInDec].		"If the angle is over 359 degrees, then convert it to the range 0...350 degrees."	(tmpAngle > 359) ifTrue: [tmpAngle := tmpAngle \\ 360].		angle := tmpAngle degreesToRadians.! !!BouncyBall methodsFor: 'geometry' stamp: 'MJK 7/11/2012 14:38'!move:distance	|newX newY|		"Check if we are still inside the boundaries of the owner object."	self checkBounds.		"Calculate a new position."	newX := (self position x + (distance * angle sin)) rounded.	newY := (self position y + (distance * angle cos)) rounded.			"Check if the new position is outside of the owner boundaries. If it is, then we assume that an edge has been reached and it is time to calculate a bouncing angle."	((newX < owner left) or: (newX + self width > owner bounds right)) ifTrue: [		self direction: 360 - self direction.		newX := (self position x + (distance * angle sin)) rounded.		newY := (self position y + (distance * angle cos)) rounded.		].	((newY < owner top) or: (newY + self height > owner bounds bottom)) ifTrue: [		self direction: 180 - self direction.		newX := (self position x + (distance * angle sin)) rounded.		newY := (self position y + (distance * angle cos)) rounded.		].		self position: newX@newY.! !!BouncyBall methodsFor: 'initialization' stamp: 'MJK 7/5/2012 14:38'!initialize	super initialize.		"Set initial angle between 0...359 degrees."	self direction: 360 atRandom - 1.! !!BouncyBall methodsFor: 'stepping and presenter' stamp: 'MJK 7/5/2012 14:42'!step	"One step in antimation. Step a ball 10 pixels at time."		super step.	self move: 10.! !!BouncyBall methodsFor: 'stepping and presenter' stamp: 'MJK 7/11/2012 14:46'!stepTime	"Step time in ms."		^10! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BouncyBall class	instanceVariableNames: ''!!BouncyBall class methodsFor: 'examples' stamp: 'MJK 7/11/2012 14:39'!example1	|m|	m := Morph new openInWorld.	m position: 150@50.	m extent: 400@300.	m addMorph: BouncyBall new.	m addMorph: BouncyBall new.	m addMorph: BouncyBall new.! !